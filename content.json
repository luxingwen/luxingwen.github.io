{"meta":{"title":"Lewis Xingwen blog","subtitle":"","description":"","author":"Lewis Xingwen","url":"https://luxingwen.github.io","root":"/"},"pages":[{"title":"About me","date":"2019-11-25T03:49:48.468Z","updated":"2019-11-25T03:49:48.468Z","comments":false,"path":"about/index.html","permalink":"https://luxingwen.github.io/about/index.html","excerpt":"","text":"一名游戏服务器开发程序员，在广州工作。 contact mail shuaicode@gmail.com 935232474@qq.com"},{"title":"分类","date":"2019-11-24T14:37:04.114Z","updated":"2019-11-24T14:37:04.114Z","comments":false,"path":"categories/index.html","permalink":"https://luxingwen.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-24T15:35:00.744Z","updated":"2019-11-24T15:35:00.744Z","comments":true,"path":"links/index.html","permalink":"https://luxingwen.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-24T14:37:04.114Z","updated":"2019-11-24T14:37:04.114Z","comments":false,"path":"tags/index.html","permalink":"https://luxingwen.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-24T14:53:30.519Z","updated":"2019-11-24T14:53:30.519Z","comments":false,"path":"repository/index.html","permalink":"https://luxingwen.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"这一辈子可能都不曾想过，最后会和陆先生走到一起","slug":"这一辈子可能都不曾想过，最后会和陆先生走到一起","date":"2020-05-26T06:16:24.000Z","updated":"2020-05-26T07:21:30.380Z","comments":true,"path":"2020/05/26/这一辈子可能都不曾想过，最后会和陆先生走到一起/","link":"","permalink":"https://luxingwen.github.io/2020/05/26/%E8%BF%99%E4%B8%80%E8%BE%88%E5%AD%90%E5%8F%AF%E8%83%BD%E9%83%BD%E4%B8%8D%E6%9B%BE%E6%83%B3%E8%BF%87%EF%BC%8C%E6%9C%80%E5%90%8E%E4%BC%9A%E5%92%8C%E9%99%86%E5%85%88%E7%94%9F%E8%B5%B0%E5%88%B0%E4%B8%80%E8%B5%B7/","excerpt":"","text":"我和陆先生相识于7年前，那时他大一，我大二。作为老乡学姐，理应多给予一些同样在异乡求学的学弟学妹们一些帮助。我还记得我和陆先生第一次见面的场景————行知大道。尴尬的聊了几句。后面我们一起发传单，见证他的感情经历…… 那时的我们，真的就和亲姐弟一般，我视他为弟弟而陆先生，总是习惯性地叫我学姐。陆先生说：我那个时候对他很好，其实，关于这一点，我并没有太多印象亦或者是我觉得他所谓的好，在我看来是很平常的一件事故而，我自己也没有放在心上。 大学那三年，我和陆先生的友情一直很好，尽管他后来有女朋友但是并没有影响我们之间的姐弟情，待他的女友也一样好。 我和陆先生分开，断绝联系，是发生在她和女朋友闹分手之际，那几天，他总找我，向我诉说他们之间的事，希望我能够帮他挽回女朋友，我知道他很难过，也很着急。而我自己，也因为感情，一直和异性保持距离，连话都不敢讲，陆先生那几天找我找的太频繁了，我很无难……那一天，正巧我是在昆明飞机场，我印象很深刻是的，朋友，我要把你删了，倘若以后自由了，我一定向你道歉，于是，我编辑了一段很尴尬的文字，大概意思是很爱前任，为了前任要放弃异性朋友。 当陆先生看到那段文字，他的内心应该是很绝望吧。一边是自己相恋多年的女友，一边是自己的知心姐姐。这一时刻，她们都要离他而去。 这三年，我是真心把陆先生当弟弟看，从未有过男女之情，加上失恋双重打击。编辑那条QQ信息的时候，我便暗自许下承诺。——————— 倘若那天自由了，一定要和陆先生道歉，解释当时的原因。 至于陆先生接不接受道歉，或者是否已经淡忘都通通没关系，我只求心安。就这样，我和陆先生长达4年未曾有过一丝的联系。 和陆先生失联的这四年，我是过得极其悲惨的而且是痛到骨子里的痛，这种痛可能一辈子都难以疫合。后面得知陆先生这四年，过得也不是很好对于感情，我和陆先生都经历过伤痛，也学会了珍惜。其实我挺感谢这次疫情的因为疫情的特殊，让我无处可去，最后选择回家，倘若不是疫情，或许我会换一个地方重新开始，是疫情，让我回了家，那时我整整2年没回过家了。 我在家一待便待了2个多月，是的，我自由了。这期间，我想过陆先生，想起过那个承诺。 很快脑海里便会有另外一个想法———————— 时间都过了那么久了，他会不会已经淡忘了呢？ 于是，我犹豫了，或者人家已经有女朋友，结婚了也说不定的， 就这样，我打消了这个念头。 不知道过了多久，这个念头又在脑海中闪现。那一天,我又是一个人空在家，当时我想——————— 要做一个守信用的人，既然自己当年许下承诺 为何现在不去实现呢？ 于是，我开始大量地去翻说说评论找陆先生。查找的过程有些纠结，怕找错，加错。这样的话会很尴尬，最后，我猜定这一个一定是陆先生，大胆地加去吧。到不了加错了重新在找一次。 接下来骗有一点程序化—-输QQ号—-姓名验证—-加友成功。 那一天是2020年4月24晚，我开口第一句便问： 陆兴文？ .... 你有女朋友没? ....在确定他单身之后，我告诉了他我的来意让我意外的是，他还记得我，甚至也深深的牵挂过我。从加好友那一刻起，我们就停不下来了他和我讲了这几年的遭遇那一晚，我们聊了接近一个通宵，一切就像是学生时代一样，好像一点都没有变，又好像一切都变了。","categories":[],"tags":[{"name":"queen","slug":"queen","permalink":"https://luxingwen.github.io/tags/queen/"}]},{"title":"我的滑板女神第一天上路","slug":"我的滑板女神第一天上路","date":"2020-05-24T03:19:59.000Z","updated":"2020-05-24T03:26:56.178Z","comments":true,"path":"2020/05/24/我的滑板女神第一天上路/","link":"","permalink":"https://luxingwen.github.io/2020/05/24/%E6%88%91%E7%9A%84%E6%BB%91%E6%9D%BF%E5%A5%B3%E7%A5%9E%E7%AC%AC%E4%B8%80%E5%A4%A9%E4%B8%8A%E8%B7%AF/","excerpt":"","text":"第一天上路就遇到下雨，还摔了一跤，动都不敢动。 Your user agent does not support the HTML5 Video element.","categories":[],"tags":[{"name":"queen","slug":"queen","permalink":"https://luxingwen.github.io/tags/queen/"}]},{"title":"about-queen","slug":"about-queen","date":"2020-05-07T12:30:12.000Z","updated":"2020-05-07T12:41:03.051Z","comments":true,"path":"2020/05/07/about-queen/","link":"","permalink":"https://luxingwen.github.io/2020/05/07/about-queen/","excerpt":"","text":"以后好好宠我的小公主1、不能和其它异性走得太近、要高冷,不能当中央空调。2、不能把锅甩给宝贝，要自己扛着。3、宝贝大姨妈时间大概在13号左右。4、宝贝吃芒果轻微过敏。5、宝贝火锅喜欢吃薄荷。6、宝贝头发乱了要去帮忙整理。","categories":[],"tags":[{"name":"queen","slug":"queen","permalink":"https://luxingwen.github.io/tags/queen/"}]},{"title":"my-queen","slug":"my-queen","date":"2020-05-07T12:09:34.000Z","updated":"2020-05-11T12:08:43.279Z","comments":true,"path":"2020/05/07/my-queen/","link":"","permalink":"https://luxingwen.github.io/2020/05/07/my-queen/","excerpt":"","text":"嘿！这是我的女王大人 Your user agent does not support the HTML5 Video element. Your user agent does not support the HTML5 Video element. Your user agent does not support the HTML5 Video element.","categories":[],"tags":[{"name":"queen","slug":"queen","permalink":"https://luxingwen.github.io/tags/queen/"}]},{"title":"糟糕的2019","slug":"糟糕的2019","date":"2019-12-31T01:15:27.000Z","updated":"2019-12-31T03:17:30.756Z","comments":true,"path":"2019/12/31/糟糕的2019/","link":"","permalink":"https://luxingwen.github.io/2019/12/31/%E7%B3%9F%E7%B3%95%E7%9A%842019/","excerpt":"","text":"人们往往只记得生活对他的苦，却不记得生活对他的甜。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://luxingwen.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Erlang实现简单的文件传输_类似ftp","slug":"Erlang实现简单的文件传输_类似ftp","date":"2019-10-01T14:10:39.000Z","updated":"2019-11-24T15:41:20.072Z","comments":true,"path":"2019/10/01/Erlang实现简单的文件传输_类似ftp/","link":"","permalink":"https://luxingwen.github.io/2019/10/01/Erlang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93_%E7%B1%BB%E4%BC%BCftp/","excerpt":"","text":"不同Erlang主机节点简单的文件传输当我们需要在两台不同的主机上进行文件传输（上传，下载），类似ftp的功能。 如果我们两台机器都装有了Erlang，那么问题就变得简单了起来。 现在我有两台机器，它分别是MacBook Pro 和一台PC，为了学习方便，它们都装上了Erlang。 它们的ip地址如图 在pc启动我们的Erlang节点。(pc是windows系统，所以我们使用werl的方式启动我们的Erlang) werl -name pc@192.168.3.2 -setcookie asd 在MBP上启动另外一个节点。 erl -name mbp@192.168.3.3 -setcookie asd 在mbp节点上，连接我们的pc节点。 1234(mbp@192.168.3.3)1&gt; net_kernel:connect_node('pc@192.168.3.2').true(mbp@192.168.3.3)2&gt; nodes().['pc@192.168.3.2'] 这样就连接成功了，nodes() 会返回我们连接的节点列表。 查看pc上当前的工作目录。 12(mbp@192.168.3.3)3&gt; rpc:call('pc@192.168.3.2', file, get_cwd, []).&#123;ok,\"d:/work/erlang/study\"&#125; 列出pc当前工作目录下的文件列表 12(mbp@192.168.3.3)4&gt; rpc:call('pc@192.168.3.2', file, list_dir, [\".\"]).&#123;ok,[\"bg.png\",\"ftp\",\"test.txt\"]&#125; 把文件下载到本地。 12345678910(mbp@192.168.3.3)5&gt; &#123;ok, Bin&#125; = rpc:call('pc@192.168.3.2', file, read_file, [\"test.txt\"]).&#123;ok,&lt;&lt;230,136,145,230,152,175,230,181,139,232,175,149, 230,150,135,228,187,182&gt;&gt;&#125;(mbp@192.168.3.3)6&gt; file:write_file(\"test.txt\", Bin).ok(mbp@192.168.3.3)7&gt; file:list_dir(\".\").&#123;ok,[\"words.sql\",\"broadcast.erl\",\"broadcast.beam\", \"test.txt\"]&#125; 把文件上传到远程节点 12345678(mbp@192.168.3.3)8&gt; &#123;ok, Bin2&#125; = file:read_file(\"words.sql\").&#123;ok,&lt;&lt;\"/*\\r\\nNavicat MySQL Data Transfer\\r\\n\\r\\nSource Server : local\\r\\nSource Server Version : 50718\\r\\nSource Host\"...&gt;&gt;&#125;(mbp@192.168.3.3)9&gt; rpc:call('pc@192.168.3.2', file, write_file, [\"words.sql\", Bin2]).ok(mbp@192.168.3.3)10&gt; rpc:call('pc@192.168.3.2', file, list_dir, [\".\"]).&#123;ok,[\"bg.png\",\"ftp\",\"test.txt\",\"words.sql\"]&#125; 这样就okok啦。","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"}]},{"title":"Erlang运行时错误","slug":"Erlang运行时错误","date":"2019-10-01T14:10:39.000Z","updated":"2019-11-24T15:32:43.549Z","comments":true,"path":"2019/10/01/Erlang运行时错误/","link":"","permalink":"https://luxingwen.github.io/2019/10/01/Erlang%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF/","excerpt":"","text":"运行时错误 函数子句错误 发生函数子句(function clause)错误的最可能原因是：函数的所有卫语句或所有的匹配模式都失败了。 case 子句错误 当忘记了一个特定的情况、传入的数据类型错误或者需要一个匹配一切的子句时，会发生case子句(case clause)错误。 if子句错误 if子句(if clause)错误的原因和case子句类似。当Erlang找不到一个可以求值为true的分支时，会引发这个错误。 不正确匹配错误 当模式匹配失败时，就会出现不正确匹配(bad match)错误。这通常意味着你时图进行不可能的模式匹配，对一个变量进行二次绑定或者在=操作符两边放置了不相等的东西。 不正确参数错误 不正确参数(bad argument)错误和函数子句错误类似，因为它们都和使用不正确的参数调用函数有关。 未定义函数错误 当调用了一个不存在的函数时候，会发生未定义函数(undefined function)错误。 不正确算术计算错误 当试图进行不正确的算术计算时，会发生不正确算术计算(bad arithmetic)错误，如除0或者在原子和数值之间进行算术计算。 不正确函数错误 导致不正确函数(bad function)错误最常见的原因是把变量当成函数使用，但是变量的值并不是函数。 不正确元素错误。 不正确元素(bad rarity)错误时不正确函数错误的特殊情况。当使用高阶函数时，给它们传递的参数个数多于或者少于实际参数个数时会出现这个错误。 系统限制错误 出现系统限制错误的原因有很多，下面是其中的一些： 进程太多 原子太长 函数参数个数太多 原子太多 连接的节点数太多","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"}]},{"title":"ETS","slug":"ets","date":"2019-09-29T14:45:39.000Z","updated":"2019-11-24T15:22:52.662Z","comments":true,"path":"2019/09/29/ets/","link":"","permalink":"https://luxingwen.github.io/2019/09/29/ets/","excerpt":"","text":"ETS键值存储，查找时间为常量。 四种不同的类型 集合（set) 相同的key-value元组只能出现一次。 包（bag) 每种key-value元组组合只能出现一次，但是同一个key可以出现多次。 重复包(duplicate bag) 允许重复的元组。 有序集合（ordered set) 相同的key-value元组只能出现一次，但是可以按key的顺序访问各个元组。 访问有序集合（ordered set)类型中的元素需要消耗表长度的对数级别的时间（oLog n),访问其余类型的元素只需要消耗常量级别的时间。 表权限 public 允许任何进程访问（读写）。 private 只有拥有该表的进程才能访问。 protected 任何进程都可以读，只有拥有该表的进程才能写入。 其它参数 {keypos, N} 创建表的时候可以通过 {keypos, N} 指定键取自那个位置，对存储记录record非常的有用。 named_table 如果存在此选项，则以表的名称注册该表，然后在后续的操作使用该表名称而不是表的标识符。要获取指定标的标识符，可以使用 whereis/1。 {write_concurrency, boolean()} 默认为false。这种情况下，对表的写入修改的操作获得独占访问，阻塞对同一表的任何并发访问。如果设置为true，则表将优化为并发写访问。 {read_concurrency, boolean()} 默认为false。如果设置为true，则该表将优化为并发读访问。 compressed 压缩，如果存在此选项，那么将以更紧凑的格式存储表数据，以消耗更少的内存。但是，这会使表操作变慢。特别是需要查找整个对象（如match，select)这种操作，速度会慢很多，关键元素不会被压缩。","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"},{"name":"ets","slug":"ets","permalink":"https://luxingwen.github.io/tags/ets/"}]},{"title":"Ekka源码阅读","slug":"ekka源码阅读","date":"2019-09-29T14:45:39.000Z","updated":"2019-11-24T15:41:25.872Z","comments":true,"path":"2019/09/29/ekka源码阅读/","link":"","permalink":"https://luxingwen.github.io/2019/09/29/ekka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"Ekka源码阅读Ekka是emqx自动集群和自动愈合的一个组件。 节点发现与自动集群ekka_cluster_strategy 模块定义了一些行为。它们分别是： 12345678910111213141516-type(options() :: list(proplists:property())).%% 发现-callback(discover(options()) -&gt; &#123;ok, list(node())&#125; | &#123;error, term()&#125;).%% 锁-callback(lock(options()) -&gt; ok | ignore | &#123;error, term()&#125;).%% 解锁-callback(unlock(options()) -&gt; ok | ignore | &#123;error, term()&#125;).%% 注册-callback(register(options()) -&gt; ok | ignore | &#123;error, term()&#125;).%% 移除注册-callback(unregister(options()) -&gt; ok | ignore | &#123;error, term()&#125;). ekka_cluster模块提供一些集群的API调用和集群管理的RPC调用。它们分别是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879%% Cluster API-export([ join/1, %% 加入 leave/0, %% 离开 force_leave/1, %% 强制离开 status/0 %% 状态 ]).%% RPC Call for Cluster Management-export([ prepare/1, heal/1, reboot/0 ]).%% @doc Join the cluster%% 加入集群-spec(join(node()) -&gt; ok | ignore | &#123;error, any()&#125;).%% 如果节点是当前节点，则忽略join(Node) when Node =:= node() -&gt; ignore;join(Node) when is_atom(Node) -&gt; case &#123;ekka_mnesia:is_node_in_cluster(Node), ekka_node:is_running(Node, ekka)&#125; of &#123;false, true&#125; -&gt; %% 如果节点没有在集群里而且节点正在运行， 则加入这个集群 prepare(join), ok = ekka_mnesia:join_cluster(Node), reboot(); &#123;false, false&#125; -&gt; %% 如果节点没有在集群里而且节点也没有运行 返回 错误 &#123;error, &#123;node_down, Node&#125;&#125;; &#123;true, _&#125; -&gt; %% 如果节点已经在集群里运行 &#123;error, &#123;already_in_cluster, Node&#125;&#125; end.%% @doc Leave from the cluster.%% 离开集群-spec(leave() -&gt; ok | &#123;error, any()&#125;).leave() -&gt; case ekka_mnesia:running_nodes() -- [node()] of [_|_] -&gt; %% 如果该节点在运行的节点列表里 离开该集群 prepare(leave), ok = ekka_mnesia:leave_cluster(), reboot(); [] -&gt; &#123;error, node_not_in_cluster&#125; end.%% @doc Force a node leave from cluster.%% 强制一个节点离开集群-spec(force_leave(node()) -&gt; ok | ignore | &#123;error, term()&#125;).%% 如果是当前节点，忽略force_leave(Node) when Node =:= node() -&gt; ignore;force_leave(Node) -&gt; %% 如果Node节点在集群里，接着rpcdia case ekka_mnesia:is_node_in_cluster(Node) andalso rpc:call(Node, ?MODULE, prepare, [leave]) of ok -&gt; case ekka_mnesia:remove_from_cluster(Node) of ok -&gt; rpc:call(Node, ?MODULE, reboot, []); Error -&gt; Error end; false -&gt; &#123;error, node_not_in_cluster&#125;; &#123;badrpc, nodedown&#125; -&gt; ekka_membership:announce(&#123;force_leave, Node&#125;), ekka_mnesia:remove_from_cluster(Node); &#123;badrpc, Reason&#125; -&gt; &#123;error, Reason&#125; end.%% @doc Cluster status.%% 集群状态status() -&gt; ekka_mnesia:cluster_status(). ekka_autocluster 自动集群模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980-spec(run(atom()) -&gt; any()).run(App) -&gt; %% 获得锁 case acquire_lock(App) of ok -&gt; spawn(fun() -&gt; %% 把当前进程的组长设置为init group_leader(whereis(init), self()), %% 等待应用准备就绪 wait_application_ready(App, 10), try %% 发现且加入 discover_and_join() catch _:Error:Stacktrace -&gt; ?LOG(error, \"Discover error: ~p~n~p\", [Error, Stacktrace]) after %% 释放锁 release_lock(App) end, %% 可能需要再次运行 maybe_run_again(App) end); failed -&gt; ignore end.%% 等待节点运行应用wait_application_ready(_App, 0) -&gt; timeout;wait_application_ready(App, Retries) -&gt; case ekka_node:is_running(App) of true -&gt; ok; false -&gt; timer:sleep(1000), wait_application_ready(App, Retries - 1) end.%% 可能需要在尝试一次maybe_run_again(App) -&gt; %% Check if the node joined cluster? %% 检查节点是否在集群里 case ekka_mnesia:is_node_in_cluster() of true -&gt; ok; false -&gt; %% 如果节点没有加入集群， 5秒后再次重试 timer:sleep(5000), run(App) end.-spec(discover_and_join() -&gt; any()).discover_and_join() -&gt; with_strategy( fun(Mod, Options) -&gt; case Mod:lock(Options) of ok -&gt; discover_and_join(Mod, Options), log_error(\"Unlock\", Mod:unlock(Options)); ignore -&gt; timer:sleep(rand:uniform(3000)), discover_and_join(Mod, Options); &#123;error, Reason&#125; -&gt; ?LOG(error, \"AutoCluster stopped for lock error: ~p\", [Reason]) end end).-spec(acquire_lock(atom()) -&gt; ok | failed).%% 获取锁acquire_lock(App) -&gt; %% 如果应用程序APP的配置参数 autocluster_lock没有被设置值，则设置为true，表示获得锁成功，否则获取锁失败 case application:get_env(App, autocluster_lock) of undefined -&gt; application:set_env(App, autocluster_lock, true); &#123;ok, _&#125; -&gt; failed end.-spec(release_lock(atom()) -&gt; ok).%% 释放锁release_lock(App) -&gt; %% 清除应用程序APP的配置参数 autocluster_lock application:unset_env(App, autocluster_lock).","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"}]},{"title":"源码构建emqx以及其第三方插件","slug":"源码构建emqx以及其第三方插件","date":"2019-09-29T14:45:39.000Z","updated":"2019-11-25T03:52:38.767Z","comments":true,"path":"2019/09/29/源码构建emqx以及其第三方插件/","link":"","permalink":"https://luxingwen.github.io/2019/09/29/%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAemqx%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/","excerpt":"","text":"源码构建emqx以及其第三方插件要想编译emqx以及其第三方插件，使用emqx-rel 这个项目来构建。官方写的还是比较明白，对于没有重来都没有接触过Erlang的小伙伴来说可能会遇到一些问题。 首先，源码安装最新版的Erlang和rebar3linux 查看 Linux源码安装Erlang-添加OpenSSL依赖,安装rebar3 这篇文章 mac 查看 https://www.jianshu.com/p/efeced0cf8f7 这篇文章 因为需要openssl 依赖，不是源码安装可能没有，到时候编译的时候可能会通过，运行时可能会报错。所以，这里还是选择源码安装Erlang，把依赖手工加上。 源码构建emqx$ git clone https://github.com/emqx/emqx-rel.git $ cd emqx-rel $ make 第一次构建，rebar3 会帮我们去下载依赖。它使用的是git，所以，电脑上必须的装有 git，而且可以正常 clone github上的项目。 启动 emqx $ _build/emqx/rel/emqx/bin/emqx start 停止 emqx $ _build/emqx/rel/emqx/bin/emqx stop 编译第三方插件如果你可以源码正确构建 emqx，那么构建第三方插件 应该很简单才对。 你可以试着 根据 https://github.com/luxingwen/emqx-mysql 上所写的文档来构建 emqx-mysql 这个插件。 最后我使用的是 Ubuntu。若你在构建emqx 及其 第三方插件时还有 疑问，请在https://github.com/luxingwen/learning-erlang 提交issue上与我联系，交流。","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"}]},{"title":"分布式架构","slug":"分布式架构","date":"2019-09-21T14:45:39.000Z","updated":"2019-11-24T15:34:15.679Z","comments":true,"path":"2019/09/21/分布式架构/","link":"","permalink":"https://luxingwen.github.io/2019/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/","excerpt":"","text":"可伸缩的分布式Erlang 面向服务和微服务的架构 点对点","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"}]},{"title":"分布式Erlang","slug":"分布式Erlang","date":"2019-09-19T14:45:39.000Z","updated":"2019-11-24T15:33:19.125Z","comments":true,"path":"2019/09/19/分布式Erlang/","link":"","permalink":"https://luxingwen.github.io/2019/09/19/%E5%88%86%E5%B8%83%E5%BC%8FErlang/","excerpt":"","text":"分布式ErlangErlang内置了相关接口允许程序跨多节点允许：多个进程可以透明地在其他节点分裂出进程，并且相互通过发送消息来通讯。分布式的各个节点都可以位于同一台物理主机上，也可以分布在不同的主机上。 命名与通讯一个Erlang节点想要成为分布式Erlang系统的一部分，它必须拥有一个名字。 节点间的连接与可见性为了能够相互通讯，Erlang的节点之间必须共享一个私密的cookie值。 如果一组节点共享相同的cookie值，它们中的任何一个节点便都能够知道其他所有节点的存在，并且可以相互交互。如果在启动节点带上 -hidden 标志，这样该节点便不会自动与任何节点连接了。使用net_kernel模块可以对此进行细粒度的控制，还能控制互联的其它方面。 分布式应用在多个Erlang节点的分布式系统中，如果正在运行的某个应用程序节点发生故障，则另外一个节点重新启动该应用程序。 指定分布式应用通过以下配置参数来指定分布式应用程序。 distributed = [{Application，Timeout, NodeDesc}] Application = atom() 指定应用程序 Timeout = integer() 指定另一个节点重新启动之前等待的毫秒数。默认0。 NodeDesc = [Node1 | {Node2, Node3}] 是优先级顺序的节点名称列表。 为了使分布式程序正常工作， 可以运行的节点必须相互联系并协商启动应用程序的配置。使用一下的配置参数来完成。 sync_nodes_mandatory = [Node] - 指定必须启动的其他节点（在sync_nodes_timeout指定的超时时间内 ）。 sync_nodes_optional = [Node] - 指定可以启动的其他节点（在sync_nodes_timeout指定的超时时间内 ）。 sync_nodes_timeout =integer（）| infinity - 指定等待其他节点启动的毫秒数。 eg: myapp这个应用程序运行在节点 node1@lxw,如果这个节点崩溃。myapp将在节点node2@lxw 或者 node3@lxw 重新启动。这个node1@lxwde 配置文件 node1.config如下。 1234567[&#123;kernel, [&#123;distributed, [&#123;myapp, 5000, [node1@lxw, &#123;node2@lxw, node3@lxw&#125;]&#125;]&#125;, &#123;sync_nodes_mandatory, [node2@lxw, node3@lxw]&#125;, &#123;sync_nodes_timeout, 5000&#125; ] &#125;]. 对于node2@lxw和node3@lxw的配置文件，除了sync_nodes_mandatory的节点列表不同，其它都是相同的。node2@lxw的是[node1@lxw, node3@lxw], node3@lxw的是[node1@lxw, node2@lxw]。 sync_nodes_mandatory 元组要结合sync_nodes_timeout一起使用。当用这个配置启动分布式节点时，节点会一直处于锁定状态，直到所有节点都启动并被锁定，接着，它们之间会进行同步，然后在继续运行。如果启动的所有节点时间超过了 sync_nodes_timeout 配置的时间，那么它们都将崩溃。 启动和停止分布式应用程序当所有的节点都已经启动时，通过在所有节点上调用 application:start(Application) 来启动分布式应用程序。 也可以使用启动脚本自动启动应用程序。 eg： 123erl -sname node1 -config node1erl -sname node2 -config node2erl -sname node3 -config node3 加入启动 application:start(Application) 参数 123erl -sname node1 -config node1 -eval \"application:start(Application)\"erl -sname node2 -config node2 -eval \"application:start(Application)\"erl -sname node3 -config node3 -eval \"application:start(Application)\" 同样，需要在所有相关节点上调用 applicaiont:stop(Application) 来停止应用程序。 故障转移如果正在运行应用程序的节点发生故障，则应用程序将在分布式配置参数中的节点列表中列出的第一个操作节点上重新启动（在指定的超时时间之后）。这称为 故障转移。 应用程序在新节点上以正常方式启动，调用： Module:start(normal, StartArgs) 恢复如果启动节点，这个节点在分布式应用程序中有更高的运行优先权，这个应用程序将在新的节点启动，在老的节点停止，这个称为恢复。 应用程序启动通过调用： Module:start({takeover, Node}, StartArgs)","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"}]},{"title":"Linux源码安装Erlang-添加OpenSSL依赖,安装rebar3","slug":"Linux源码安装Erlang-添加OpenSSL依赖,安装rebar3","date":"2019-09-17T14:45:39.000Z","updated":"2019-11-25T03:47:33.573Z","comments":true,"path":"2019/09/17/Linux源码安装Erlang-添加OpenSSL依赖,安装rebar3/","link":"","permalink":"https://luxingwen.github.io/2019/09/17/Linux%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85Erlang-%E6%B7%BB%E5%8A%A0OpenSSL%E4%BE%9D%E8%B5%96,%E5%AE%89%E8%A3%85rebar3/","excerpt":"","text":"先安装openssl下载openssl源码 $ wget http://www.openssl.org/source/openssl-1.0.2a.tar.gz $ tar -zxvf openssl-1.0.2a.tar.gz 进入源码目录，注意如果不是最新下的目录，需要先执行 make clean 确保能够重新编译成功为了不和系统的openssl冲突，我们安装的时候需要指定安装的路径 $ make clean $ ./configure –prefix=/usr/local/opt config之后，会生成Makefile，打开Makefile找到cc，在CFLAG参数列表里加上-fPIC CC= cc CFLAG= -fPIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -Wa,—noexecstack -m64 -DL_ENDIAN -DTERMIO -O3 -Wall -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM 编译并安装 $ sudo make &amp;&amp; make install 安装Java如果没有jdk，务必自行安装下jdk1.6 以上 安装erlang官网下载最新的Erlang源码包。https://www.erlang.org/downloads 解压，然后进入到erlang源码目录下。 $ make clean $ sudo ./configure –prefix=/your/path/erlang –with-ssl=/usr/local/opt/ssl –without-javac $ sudo make &amp;&amp; make install 如果安装过程中报错，出现依赖缺失，先安装缺失依赖，然后在依次执行以上几个命令 添加环境变量 1export PATH=$PATH:/your/path/erlang/bin 安装rebar3从官网下载 rebar3 https://www.rebar3.org/ 赋予可执行权限 $ sudo chmod a+x rebar3 复制到shell可访问的bin目录 或者添加到环境变量。我这里选择的是 复制到 bin目录 $ sudo mv rebar3 /usr/local/bin 最后如果有什么问题，请在 https://github.com/luxingwen/learning-erlang 提交issue与我交流","categories":[{"name":"Erlang","slug":"Erlang","permalink":"https://luxingwen.github.io/categories/Erlang/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"https://luxingwen.github.io/tags/erlang/"},{"name":"rebar3","slug":"rebar3","permalink":"https://luxingwen.github.io/tags/rebar3/"}]},{"title":"桂林阳朔两日游","slug":"桂林阳朔两日游","date":"2019-03-10T14:45:39.000Z","updated":"2019-11-25T03:29:24.105Z","comments":true,"path":"2019/03/10/桂林阳朔两日游/","link":"","permalink":"https://luxingwen.github.io/2019/03/10/%E6%A1%82%E6%9E%97%E9%98%B3%E6%9C%94%E4%B8%A4%E6%97%A5%E6%B8%B8/","excerpt":"","text":"最近太闷了，所以决定一个人出去走一走。 又不想去太远，所以选择了较近的桂林。 周五下班后，广州出发，晚上11点到桂林北站，索性在桂林北站附近休息。 第二天约了在桂林念研究生的大学同学在十字街见面。 先步行在日月双塔小逛一会，接着就去象鼻山。 因为象鼻山成人票要55元，而外面吆喝坐船的只需要50，所以最后选择了坐船。 游船说游10坐山，可是7星山就包含了7座山，然后一下子就过了。 差不多也到了中午，我们选择到附近的十字街先吃一点东西。 吃完东西下午听别人推荐的，去了芦笛岩，个人觉得这个比较坑，不推荐去。也许我不喜欢去溶洞里面游玩吧？里面手机信号都没有。 从芦笛岩出来后，同学推荐了性价比比较高的叠彩山爬。 听说夜景的日夜双塔很漂亮，吃过晚饭后又去日夜双塔逛一逛。 玩了一天，挺开心的。桂林市区基本算是逛完了，在同学的建议下，我决定再去阳朔玩一玩。桂林山水甲天下，阳朔山水甲桂林。 因为我打算周日晚上就回广州。行程挺赶的，所以我就报了一个团。反正也不贵，100来大洋。 我报的这个团，一大车的大妈大爷们。感觉自己提前进入了老年生活。 月亮山，摆一个台子就收费拍照，2块2块，赶快上车，这车开往老年活动中心。 接下来去金水岩，又是进洞。 看表演，大妈大爷的数量超乎我的想象。 接下来，作为单身狗的我，接到了阿妹给我抛的绣球，然后，我结婚啦。 看完表演后，导游带我们去一个他们合作的农庄吃饭，在去的路上推销一些吃的，不过我没有买。因为听了同学的，所以我买了很多零食。 下午就是去游漓江，20RMB的地方啦。听说竹筏不怎么好玩，所以我选择坐船。 最后。游玩漓江后我就和导游说我自己去阳朔站坐高铁。 看着时间还早，我就把早先买了8点的那趟退了，重新买了下午6点这趟到广州。 即使是一个人出来游玩，也挺有意思的。 如果你很闷，那么就出去走走吧。 今天甩甩小哥哥特开心。 End","categories":[{"name":"在路上","slug":"在路上","permalink":"https://luxingwen.github.io/categories/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"}],"tags":[{"name":"桂林","slug":"桂林","permalink":"https://luxingwen.github.io/tags/%E6%A1%82%E6%9E%97/"},{"name":"阳朔","slug":"阳朔","permalink":"https://luxingwen.github.io/tags/%E9%98%B3%E6%9C%94/"}]},{"title":"玩在广州","slug":"玩在广州","date":"2018-09-29T14:45:39.000Z","updated":"2019-11-25T03:21:06.480Z","comments":true,"path":"2018/09/29/玩在广州/","link":"","permalink":"https://luxingwen.github.io/2018/09/29/%E7%8E%A9%E5%9C%A8%E5%B9%BF%E5%B7%9E/","excerpt":"","text":"不知不觉，已经在广州工作两年多。 广州有啥好玩的地方呢？大部分广州人都会回答你说：没啥好玩的。呆久了，我也会产生这种感觉。回想起来，广州还是有挺多好玩的地方的。 如果你来广州，我会带你去中山纪念堂逛一逛，虽然没啥好看的，但孙中山作为我国近代民族主义的开括者，还是值得一去吧。 随后带你去石圣心大教堂坐一坐。 接着去沙面溜一圈，沙面乃以前的租界，由英国人一手建造而成。 从沙面出来直接坐水巴到中大港口，水巴和公交车一样，两块钱就能坐。 然后去中大校园溜达溜达，中大老校区有着许多古老的建筑物到现在依旧保存着。 从中大出来在继续坐船到广州塔。 广州塔由称小蛮腰，乃亚洲第一高塔。 在广州塔隔江对面就是广州市中心、CDB、珠江新城。 从广州塔下乘坐有鬼（轨）电车到万胜围，途中经过会展中心。也可以进去逛逛（虽然到目前为止我还没有去过）。 万胜围（广州地铁博物馆）。 继续搭乘有鬼电车到广州塔。晚上的话可以在琶醍下车，琶醍有很多酒吧，可以到里面喝上几杯。 广州塔港买船票，夜游珠江，广州的夜景非常的漂亮。 在广州塔搭乘APM（无人自动驾驶列车）到海心沙。 海心沙是广州举办亚运会的地方，现在上面有许多餐厅，很有情调。 随后在花城广场转一转。广州图书馆趁一下Wi-Fi，广图的Wi-Fi速度非常快，我经常去趁。 猎德大桥上走一走？我觉得猎德大桥是广州最帅的桥，我每天上班都要从上面经过，尽管每次都塞车，但是我还是觉得它很帅。 去黄沙这个免费的水族管看海洋生物，顺便大吃一顿。 TIT创意园走一圈？ 微信总部就在此。不去看一看？ 红砖厂，你也许觉得它很破，不过它确实很破。 骑着自行车。绕着大学城岛逛一圈，广州名校基本集聚于此。 可以到黄埔军校参观一下，很多名将从这里出身，周围的风景也挺不错。 节假日的话，去岭南印象园体验岭南乡土风情和岭南民俗文化。有表演，当然人也挺多。 爬山爱好者的话，可以到白云山玩一玩。 游乐场-》长隆欢乐世界，到现在我都还木有去过呢，应该挺好玩的。 沙湾古镇，宝墨园，这两个去过一次，还好，就是有点远。 有时间的话可以跑到广州的最南端南沙。可以吃到较便宜的海鲜（相对市区来说），到南沙客运港看一看，可以从那里坐船到世界各地的。这里也是珠江的入海口，对大海有很大期望的建议还是先别来了。 购物我觉得，广州就是女生的购物天堂啊。专门为女生设计的一般… 带你去体育中心、体育西逛一圈。天环广场Apple store里面免费玩下最新款的苹果全家桶。 太古汇看名牌。土豪的你在里面买上几个lv包也挺不错，顺便我也沾沾光，毕竟我每天上下班在门口走来走去也未曾进去逛过。 还不够的话，再去上下九溜达一圈。 还在不行？自己溜达去吧。腿都要走断了… 最后留下来体验下上下班高峰的广州地铁，特别是3号线和5号线。 以上就是不怎么靠谱广州旅游推荐。 漂亮的广州，等待最美的你。","categories":[{"name":"在路上","slug":"在路上","permalink":"https://luxingwen.github.io/categories/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"}],"tags":[{"name":"广州","slug":"广州","permalink":"https://luxingwen.github.io/tags/%E5%B9%BF%E5%B7%9E/"}]},{"title":"深度优先搜索和广度优先搜索","slug":"深度优先和广度优先搜索","date":"2018-03-21T14:45:39.000Z","updated":"2019-11-24T16:55:04.779Z","comments":true,"path":"2018/03/21/深度优先和广度优先搜索/","link":"","permalink":"https://luxingwen.github.io/2018/03/21/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"深度优先搜索1234567891011void dfs(int step)&#123; //判断边界 //尝试每一种可能 for(int i = 1; i &lt;= n; i++)&#123; //继续下一步 dfs(step + 1); &#125; //返回 return;&#125; 广度优先搜索123456789void bfs()&#123; //声明队列 //根节点入队 while // 队列不为空 // 获取队头元素 // 获取队头元素子孩子 // 孩子入队 // 队头元素出队&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://luxingwen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://luxingwen.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"https://luxingwen.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"二叉树","slug":"二叉树","date":"2018-03-20T14:45:39.000Z","updated":"2019-11-25T03:45:53.446Z","comments":true,"path":"2018/03/20/二叉树/","link":"","permalink":"https://luxingwen.github.io/2018/03/20/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"几种遍历方式 12345678910111213141516171819202122232425262728void pre(Node *root)&#123; if(root == NULL)&#123; return; &#125; cout &lt;&lt; root -&gt; val &lt;&lt; endl; pre(root-&gt;left); pre(root-&gt;right);&#125;void mid(Node *root)&#123; if(root == NULL)&#123; return; &#125; mid(root-&gt;left); cout &lt;&lt; root -&gt; val &lt;&lt; endl; mid(root-&gt;right);&#125;void lst(Node *root)&#123; if(root == NULL)&#123; return; &#125; lst(root-&gt;left); lst(root-&gt;right); cout &lt;&lt; root -&gt; val &lt;&lt; endl;&#125; 计算二叉树深度 先计算左右子树的深度，然后整棵树的深度就是左右子树深度较大值加1（当前节点） 123456int caculDepth(Node *root)&#123; if(root == NULL)&#123; return 0; &#125; return max(caculDepth(root-&gt;left), caculDepth(root-&gt;right)) +1;&#125; 镜像二叉树 1234567void Mirror(TreeNode *pRoot) &#123; if(pRoot == NULL) return; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); swap(pRoot-&gt;left, pRoot-&gt;right);&#125; 从上往下打印出二叉树的每个节点，同层节点从左至右打印.利用广度优先搜索思想。 12345678910111213141516171819vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; vector&lt;int&gt; v; if(root == NULL) return v; q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); q.pop(); v.push_back(node-&gt;val); if(node-&gt;left != NULL)&#123; q.push(node-&gt;left); &#125; if(node-&gt;right != NULL)&#123; q.push(node-&gt;right); &#125; &#125; return v;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://luxingwen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://luxingwen.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"链表","slug":"链表","date":"2018-03-20T14:45:39.000Z","updated":"2019-11-24T16:52:07.140Z","comments":true,"path":"2018/03/20/链表/","link":"","permalink":"https://luxingwen.github.io/2018/03/20/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"反转链表 1234567891011121314ListNode* ReverseList(ListNode* pHead) &#123; if(pHead == NULL) return NULL; ListNode* cur = pHead; ListNode* pre = NULL; ListNode* next = NULL; while(cur != NULL)&#123; next = cur -&gt; next; cur -&gt; next = pre; pre = cur; cur = next; &#125; return pre;&#125; 输入一个链表，输出该链表中倒数第k个结点。 12345678910ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; vector&lt;ListNode*&gt; v; while(pListHead!=NULL)&#123; v.push_back(pListHead); pListHead = pListHead-&gt;next; &#125; if(v.size() &lt; k || k &lt; 1) return NULL; return v[v.size() - k]; &#125; 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 12345678910111213141516171819202122232425ListNode* Merge(ListNode* pHead1, ListNode* pHead2)&#123; ListNode* p = new ListNode(-1); ListNode* root= p; while(pHead1 != NULL || pHead2 != NULL)&#123; if(pHead1 == NULL)&#123; p-&gt;next = pHead2; break; &#125; if(pHead2 == NULL)&#123; p-&gt;next = pHead1; break; &#125; if(pHead1 -&gt; val &lt; pHead2 -&gt; val)&#123; p-&gt;next = pHead1; p = p-&gt;next; pHead1 = pHead1 -&gt; next; &#125;else&#123; p-&gt;next = pHead2; p = p-&gt; next; pHead2 = pHead2-&gt;next; &#125; &#125; return root-&gt;next; &#125; 输入一个链表，从尾到头打印链表每个节点的值。 1234567891011vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; v; if(head == NULL) return v; while(head != NULL)&#123; v.push_back(head-&gt;val); head = head-&gt;next; &#125; std::reverse(v.begin(), v.end()); return v;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://luxingwen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://luxingwen.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"排序","slug":"排序算法","date":"2018-01-18T14:45:39.000Z","updated":"2019-11-24T16:48:01.158Z","comments":true,"path":"2018/01/18/排序算法/","link":"","permalink":"https://luxingwen.github.io/2018/01/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"选择排序首先在数组中找到最小的元素，然后把它和第一个元素交换。然后在剩余的元素中不断的找到最小者与第一个元素交换。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void selectSort(int a[], int n)&#123; int i, j; for (i = 0; i &lt; n; i++)&#123; int minIndex = i; for(j = i + 1; j &lt; n; j ++)&#123; if (a[minIndex] &gt; a[j])&#123; minIndex = j; &#125; &#125; swap(a[minIndex], a[j]); &#125;&#125;int main()&#123; int a[10] = &#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; selectSort(a, 10); return 0;&#125; 插入排序在玩扑克牌的时候，如果都是从左到右的整理扑克，那么这个过程就是一个插入排序过程。 具体思想就是当前元素在前面已经排好序的数组中寻找合适的位置并插入进去。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void insertSort(int a[], int n)&#123; for (int i = 1; i &lt; n; i++)&#123; for (int j = i; j &gt; 0; j--)&#123; if(a[j] &lt; a[j-1])&#123; swap(a[j], a[j-1]); &#125;else&#123; break; &#125; &#125; &#125;&#125;int main()&#123; int a[10] = &#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; insertSort(a, 10); return 0;&#125; 归并排序对一个数组排序，可以将数组（递归）的分成两半进行排序，然后将结果合并起来。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int aux[10];void merge(int a[], int l, int mid, int r)&#123; int i = l, j = mid + 1; for(int k = l; k &lt;= r; k++)&#123; aux[k] = a[k]; &#125; for(int k = l; k &lt;= r; k++)&#123; if(i &gt; mid)&#123; a[k] = aux[j++]; &#125;else if(j &gt; r)&#123; a[k] = aux[i++]; &#125;else if(aux[i] &gt; aux[j])&#123; a[k] = aux[j++]; &#125;else&#123; a[k] = aux[i++]; &#125; &#125;&#125;void mergeSort(int a[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + (r - l) / 2; mergeSort(a, l, mid); mergeSort(a, mid + 1, r); merge(a, l, mid, r);&#125;int main()&#123; int a[10] = &#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; mergeSort(a, 0, 9); return 0;&#125; 快速排序快速排序是一种分治算法。它是将一个数组分割成两个子数组，与归并排序不同的是：快速排序保证左边的数组元素都要小于右边的数组元素。 首先找到一个分割点，一般以数组的第一个元素作为这个分割点，先从左边往右边找。把比这个元素小的都放在左边，比它大的放在右边，然后又从右边往左边找。当两个指针相遇时，我们只需要把该分割点的元素放到该位置即可（分割点）。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void quikSort(int a[], int begin, int end)&#123; if(begin &gt;= end)return; int i = begin; int j = end; int key = a[i]; while(i &lt; j)&#123; while(a[j] &gt;= key &amp;&amp; j &gt; i)j--; a[i] = a[j]; while(a[i] &lt;= key &amp;&amp; j &gt; i)i++; a[j] = a[i]; &#125; a[i] = key; quikSort(a, begin, i - 1); quikSort(a, i + 1, end);&#125;int main()&#123; int a[10] = &#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; quikSort(a, 0, 9); return 0;&#125; 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#define N 10using namespace std;int arr[N+1];int count = 0;void shiftUp(int k)&#123; while(arr[k/2] &lt; arr[k] &amp;&amp; k &gt; 1)&#123; swap(arr[k/2], arr[k]); k /= 2; &#125;&#125;void insert(int v)&#123; if(count + 1 &gt; N) return; arr[count + 1] = v; count++; shiftUp(count);&#125;void shiftDown(int k)&#123; while(2 * k &lt;= count)&#123; int j = 2 * k; if(j + 1 &lt;= count &amp;&amp; arr[j + 1] &gt; arr[j])&#123; j = j + 1; &#125; if(arr[k] &gt; arr[j])&#123; break; &#125; swap(arr[j], arr[k]); k = j; &#125;&#125;int popMax()&#123; if (!count) return 0; int v = arr[1]; swap(arr[1], arr[count]); count--; shiftDown(1); return v;&#125;void heapSort1(int a[], int n)&#123; for (int i = 0; i &lt; n; i++)&#123; insert(a[i]); &#125; for (int i = n - 1; i &gt;= 0; i--)&#123; a[i] = popMax(); &#125;&#125;void heapSort2(int a[], int n)&#123; for (int i = 1; i &lt;= n; i++)&#123; arr[i] = a[i -1]; &#125; for(int i = n/2; i &gt; 0; i--)&#123; shiftDown(i); &#125; count = n; for (int i = n - 1; i &gt;= 0; i--)&#123; a[i] = popMax(); &#125;&#125;int main()&#123; int a[10] = &#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; heapSort2(a, N); for (int i = 0; i &lt; N; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://luxingwen.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://luxingwen.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"自驾大理-丽江3日游","slug":"自驾大理-丽江3日游","date":"2017-10-08T14:45:39.000Z","updated":"2019-11-25T03:44:22.847Z","comments":true,"path":"2017/10/08/自驾大理-丽江3日游/","link":"","permalink":"https://luxingwen.github.io/2017/10/08/%E8%87%AA%E9%A9%BE%E5%A4%A7%E7%90%86-%E4%B8%BD%E6%B1%9F3%E6%97%A5%E6%B8%B8/","excerpt":"","text":"作为一个云南人，长这么大，还是第一次去大理&amp;丽江。 装备：姐姐的豪车。 人物：我、姐姐、表弟、老爸老妈。 司机：我和姐姐（长途开车，两人换着开不累）。 出发前的一天晚上，我们自己做了一下攻略，大概如下。 最后我们实际游程和上面的攻略还是有点出入，不过相差不是很大。 大理第一天 早上7点40从昆明出发。11点到达大理，在去景区的路边上（距离大理古城10km）随便找了一家饭馆吃，因为想着在景区吃可能比较贵，5人花费170。 吃完饭，12点。我们都觉得现在去天龙八部影视城比较早了，所以打算先去洱海边上转一圈。 所以我就一直往洱海的方向开。最后去了才村码头~（国庆人真多啊，被一个大妈带去别人客栈旁边停车，收费20元） 我和我表弟想去租电动摩托车骑一下的（60元一辆一天），最后被姐姐制止了，因为我们下午的计划是去影视城。最后就在才村码头转了一下，拍了几张照片。 随便在才村码头转了转就去天龙八部影视城了。去的路上因为我这个新司机开过了路口，浪费了约20分钟左右。 天龙八部影视城（25一人，原价50，因为景区很多地方在维护） 在大理遇到高中同桌（缘分真好），他也是一家人的来自驾游，后面就两家人一起逛。 在影视城和同桌转了转，我们约好了晚上两家人一起吃饭。因为时间还早，同桌提议说到三塔看看。 关于三塔，我们只是在外面转了转。因为门票实在是太贵了（120一人，打折下来97一人，我们10个人呢），感觉进去了也没啥好玩的。 接近6点，在美团上定了一家古城里面的饭馆，10人298，味道还挺不错的（大概是都饿了的缘故吧）。 吃完饭，顺便在古城转了转。 随便在古城逛逛，便和同桌他们道别。因为我们晚上要住在双廊，同桌他们在市区里面住。 驾车一个钟左右，最后到达客栈，可能中秋节的缘故，客栈老板拿出自家的水果、酸奶、各种零食来招待我们。 第二天 7点半起床。8点半左右从客栈出来，去吃早餐。 之后便在双廊转悠。 大游轮，140一人。 南诏岛（门票50+10块船票），好想划下面这条小船过去呢。 11点多，大家都不怎么饿。在我的提议下，决定不自驾环洱海去大理古城了，直接去丽江古城，所以加满油后直接去丽江古城。 约2两个小时后，到达丽江古城。美团了一个美国大牛哇（蛙靠），顺便把车停在了古城附近的停车场，吃过饭后就一直在丽江古城转悠呢。 丽江 丽江是个好地方 古城满大街弥漫着“就在这一瞬间 才发现 你就在我身边…”,”期待着你的回来 我的小宝贝 期待着你的拥抱 我的小宝贝 多么想牵着你的手…” 参杂着手鼓姑娘们的鼓声和她们的忧郁。 古城购物 古城里面的店大多都是外地人在经营着，正所谓无奸不商。我是体会到了，大多商家都是乱叫价。 这里我教你一招：对于你觉得贵得太离谱的商品，砍价的时候直接砍她一半还多的价格。我妈妈去看一件衣服，商家叫价160，可能你觉得这个价格算是比较正常的，我妈只给别人50。这远远小于160啊，后面商家说60卖给我们。到这里，我就已经对老妈佩服不已了，惊呆了有没有？如果这样你就觉得很厉害了，那就远远错了。后面我们从店里面走出来，走了有10米左右。那老板叫到：50卖给你们了。我对老妈说：她50卖了，快去买吧。老妈说：那件衣服没有袖子，不咋个好看。要买就买合适的，最终还是没买… 这里你可以说我在吹牛逼～不过你也不妨试试，到时候赚到的是你，又不是我。 艳遇 平时不好好耍朋友，找对象。光想着去丽江艳遇，当然是不行的。 酒托很多，酒吧酒也很贵。一杯啤酒就30大洋，一瓶红酒就成百上千了的吧？对于我这种屌丝来说，已经算是天价了。 玉龙雪山第三天 在第二天去丽江的路上，姐姐就在网上看已经没了去玉龙雪山的索道票。要去的话只有后天（7号）的票。7号肯定不能去塞，因为我7号怎么也得回到昆明，第二天坐动车回广州呢。 后面就在飞猪上面看了一个旅行策划公司还有票（套票）。458一人，包含进山门票（130）+大巴车票（好像是130？）+ 索道票（180）+ 自助餐（50块）+ 氧气（30块）+ 师傅接送，又有人带你玩。然后我们又怕被坑。再三纠结之下，还是买了这个票，因为只有这样才能去玉龙雪山玩。 早上7点，起床，把东西放在车上之后去吃了早餐，随后8点师傅就到酒店门口等我们，我们做她的车去。师傅人很好，一路上和我们有说有笑。 这天全程都是师傅带我们在玩。她不是导游，只是师傅，但是我觉得这样挺好的。 刚到甘海子的时候，远远就可以看到玉龙雪山，哇！！！我们很是想下去拍照，师傅说我们这里回来的时候在来玩。 师傅把车停到停车场后，便带我们去排队做大巴车去蓝月古。 在大巴车上就看到了蓝月谷的美，我以为就只是路过。 下了大巴车。买了电瓶车的票，50块一人（这里是单独消费，并未包含在网购的套票内）。因为师傅建议做电瓶车游览，她建议的同时也解释到这是景区内唯一自费的，其它的全都包含在套票内了，我看着也挺远的。买了票，师傅帮我们拿着氧气瓶，简单交代了一下，她到下个乘车点等我们。我们便自己在蓝月谷玩了两个钟左右，拍了很多照片。 蓝月谷 雪山雪山 蓝月谷出来后，便坐电瓶车去找师傅。随后她带我们去吃自助餐（火锅），饭没煮熟外（不知道是不是高原的缘故），味道还行的。 吃完饭，师傅便带我们去排队坐大巴车去坐索道的地方，这下真的去雪山了。 她把氧气瓶给我们后，简单交代了些去雪山的事。 拍照3张100块，真会玩 全程穿短袖装逼的250 被小伙的口才折服，拍了个照片。20大洋 甘海子&amp;逗逼的一家人 从雪山下来后，直接去找师傅。师傅说话算数，带我们去甘海子玩。 Last 最后，本来想直接就先回大理住的，结果因为事先定的酒店退不了。无奈只能在丽江留宿，因为怕堵车，所以在我的建议下，我们决定第二天早上的5点从丽江出发。 最后在酒店旁边找了一家丽江腊排骨吃过之后。又去古城转了一圈～ 对于搬砖的我来说。对此还是挺感兴趣的，我猜测它是使用的基站定位来实现的，至于预测难道是大数据？不过好像只能对移动用户定位？因为实际人流量感觉比这多得多啊 这货玩傻了 回家第四天 实际上我并没有4点半起床，我接近5点才起的。冲了个凉水澡，因为过一会要开车，我必须得马上保持清醒状态。 走得早，有好处。全程没有堵车，刚进城就开始堵。因为就在我们前面出现车祸，7张车隧道内连撞，我们在隧道外急刹车差点撞到前面那辆车。画面太….所以就不上传了。 如果有机会，我在丽江等你 总结这次游玩算是比较匆忙，因为我本来是要回家帮忙收包谷（玉米）的。不知怎么的？老头子和老妈子居然被姐姐说服出来玩（浪）。所以才有了这么几天的大理&amp;丽江自驾游，也是我第一次到大理&amp;丽江玩。我们5个人，不算下买东西（衣服什么乱七八糟的），只算门票+住宿+吃饭+照相+加油+停车，人均大概1100大洋左右。 about 玉龙雪山，个人觉得真的值得一去。第一次去还是建议买一个那个旅游策划公司的套票，（它不是跟团，就是有人带你到那里，你自己去玩。玩好了，你去找那个人，她又带你到下个地方玩，中途你玩多长时间她完全不管你的。）因为这样有人带着你去坐车，能省下很多时间，如果你一个人自己去又是第一次。绝对要大部分时间花在找坐车的地方&amp;坐车转车上面。 aoubt 购物，一定要会砍价啊，不然坑死你没得说。 第一次写游记，简直就是废话连篇&amp;写的也不好。上面的照片均是我手机所拍，如有侵犯个人隐私权，请联系我删除。","categories":[{"name":"在路上","slug":"在路上","permalink":"https://luxingwen.github.io/categories/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"}],"tags":[{"name":"大理","slug":"大理","permalink":"https://luxingwen.github.io/tags/%E5%A4%A7%E7%90%86/"},{"name":"丽江","slug":"丽江","permalink":"https://luxingwen.github.io/tags/%E4%B8%BD%E6%B1%9F/"}]}]}